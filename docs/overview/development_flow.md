
---
name: "docs/overview_0/development_flow.md"
title: "開発フロー概要 (Development Flow)"
description: "[コミットコーチ] - ステップ別の開発フロー (合計200ステップ以上)"
---

# 開発手順書 (詳細版)

以下は、**フロントエンド**と**バックエンド**の開発フローを、それぞれ 100 ステップ以上 (チェックリスト付き) でまとめた詳細な手順書です。  
全体で **200 ステップ以上** あるため、すべてを完了させるには各工程を順序立てて進めてください。

> **ポイント**  
> - フロントエンド (Step 1〜100) とバックエンド (Step 101〜200) は、**並行開発**が可能です。  
> - 必要に応じて先にモック (スタブ) を用意したり、API 定義を共有したりすることでスムーズに進められます。  
> - 実際のプロジェクトに合わせて項目を追加・修正してください。

---

## 1. 前提・共通作業

### 1.1. 初期準備 (共通)

- [ ] **Node.js** とパッケージマネージャー (npm / yarn / pnpm) をインストール  
- [ ] **Git** の初期設定（`git init` もしくはリポジトリをクローン）  
- [ ] **.gitignore** に `node_modules` やビルド生成物を除外設定  
- [ ] **エディタ/IDE** (VSCode, WebStormなど) の環境構築（ESLint, Prettier導入など）  

### 1.2. 全体方針

- [ ] フロントエンド・バックエンド間の API 仕様をざっくりと合意 (HTTPメソッド、エンドポイント構成、JSON構造など)  
- [ ] DB 設計方針や認証方法 (JWT/OAuth) などをチームで相談  
- [ ] リリースの形態 (単一リポジトリ / Monorepo / 分割リポジトリ) を決定  

この段階まで完了したら、いよいよ詳細な手順に進みます。  
以下、**フロントエンド (Steps 1〜100)** → **バックエンド (Steps 101〜200)** の順で記載していますが、並行作業可能です。

---

## 2. フロントエンド開発フロー (Step 1〜100)

以下では、フロントエンド開発を **100 ステップ** に分割し、細かいタスクを列挙しています。  
**[ ]** にチェックを入れながら作業を進めてください。

### 2.1. プロジェクト初期化 (Step 1〜10)

1. [ ] **Step 1**: `frontend/` ディレクトリを作成し、移動する  
2. [ ] **Step 2**: `npm init -y` (または `yarn init -y`, `pnpm init`) で Node.js プロジェクトを初期化する  
3. [ ] **Step 3**: 必要なライブラリ (React / Next.js / Vue / Angular など) をインストール  
4. [ ] **Step 4**: TypeScript を導入 (`npm install --save-dev typescript @types/node @types/react ...`)  
5. [ ] **Step 5**: `tsconfig.json` を作成または設定 (ターゲット, モジュール解決など)  
6. [ ] **Step 6**: `.eslintrc` と `.prettierrc` の導入 (フォーマット・コード品質チェック)  
7. [ ] **Step 7**: `package.json` の `scripts` に `dev`, `build`, `start`, `lint` などを追記  
8. [ ] **Step 8**: `npm run dev` などを試し、空のアプリが起動するか確認  
9. [ ] **Step 9**: **Gitコミット**: `git add .` → `git commit -m "Frontend init: setup project & configs"`  
10. [ ] **Step 10**: フロントエンド開発方針をドキュメント化 (フォルダ構成、使用ライブラリ一覧 など)  

### 2.2. ベースレイアウト構築 (Step 11〜20)

11. [ ] **Step 11**: `pages` や `app` ディレクトリ (Next.jsの場合) を作成し、**基本ページ**を配置  
12. [ ] **Step 12**: グローバルなスタイル (Tailwind / CSS modules / styled-components 等) を導入  
13. [ ] **Step 13**: **Header** コンポーネントを作成 (ロゴ、ナビゲーション要素など)  
14. [ ] **Step 14**: **Footer** コンポーネントを作成 (コピーライト表記など)  
15. [ ] **Step 15**: サイドバー (必要なら) を作成し、**メニュー項目**を配置  
16. [ ] **Step 16**: レスポンシブ対応 (スマホ、タブレット、PC) の基本レイアウトを実装  
17. [ ] **Step 17**: 主要な**ルーティング**を定義 (例: `/dashboard`, `/projects`, `/settings`)  
18. [ ] **Step 18**: デザインガイドライン (色、フォント、余白など) をチームと合意し、適用  
19. [ ] **Step 19**: 全ページで共通して利用する**カスタムフック**(例: `useWindowSize`) を配置  
20. [ ] **Step 20**: **Gitコミット**: "feat: add base layout with header/footer"

### 2.3. UIコンポーネントライブラリ選定・設定 (Step 21〜30)

21. [ ] **Step 21**: UIライブラリ (Material UI, Chakra UI, Ant Design, etc.) を検討・選定  
22. [ ] **Step 22**: 選定したライブラリをインストールし、初期設定を行う (テーマ設定など)  
23. [ ] **Step 23**: ボタン (`Button`), 入力フォーム (`Input`), ダイアログ (`Modal`) などの共通コンポーネントを把握  
24. [ ] **Step 24**: 既存のコンポーネント (Header/Footer) をライブラリスタイルへ統合・リファクタリング  
25. [ ] **Step 25**: **配色テーマ** (ライト/ダークモード対応など) を導入し、スイッチング実装 (オプション)  
26. [ ] **Step 26**: `components/common/` 下に、UIライブラリをラップした再利用可能コンポーネントを整理  
27. [ ] **Step 27**: スタイルガイドや Storybook 等を導入し、コンポーネント一覧を可視化 (オプション)  
28. [ ] **Step 28**: 小さなUI改善 (ホバーエフェクト, トランジション等) を追加  
29. [ ] **Step 29**: 使用ライブラリとカスタムコンポーネントの使い方を短いドキュメントにまとめる  
30. [ ] **Step 30**: **Gitコミット**: "chore: integrate UI library & custom theme"

### 2.4. 認証・ユーザー管理周り (Step 31〜40)

31. [ ] **Step 31**: ログインページを作成 (Email/Password フォーム)  
32. [ ] **Step 32**: バックエンドAPIとの認証連携 (JWT / session) の方式を決定 (仮モックでも可)  
33. [ ] **Step 33**: `useAuth` フック (またはコンテキスト) を作成し、認証状態をグローバル管理  
34. [ ] **Step 34**: ログイン後のリダイレクト処理 (例: `/dashboard` へ遷移) を実装  
35. [ ] **Step 35**: ログアウト機能 (トークン消去、またはセッション終了) の実装  
36. [ ] **Step 36**: 未ログインユーザーに対するガード (protected route) を設定  
37. [ ] **Step 37**: パスワードリセットや新規ユーザー登録が必要なら、フォームを追加 (オプション)  
38. [ ] **Step 38**: ユーザープロフィールページ (例: `/profile`) で名前やアバターを表示  
39. [ ] **Step 39**: （デザイン調整）認証画面全体のスタイルを統一し、アクセシビリティを考慮  
40. [ ] **Step 40**: **Gitコミット**: "feat: add user auth screens (login, logout, guard)"

### 2.5. ダッシュボード機能 (Step 41〜50)

41. [ ] **Step 41**: `/dashboard` ページに総合的な概要 (ユーザー名, 最新プロジェクト など) を表示  
42. [ ] **Step 42**: バックエンドからダミーデータ (API) を取得し、表示テスト  
43. [ ] **Step 43**: カードやグラフ (ライブラリを使用) を配置し、直感的なレイアウトを作る  
44. [ ] **Step 44**: ダッシュボードに**通知**や**未読メッセージ**数などを配置 (モック可)  
45. [ ] **Step 45**: バックエンド連携が未完なら、一時的にモックデータや JSON を使用  
46. [ ] **Step 46**: ダッシュボードのリフレッシュ間隔を設定 (例: 30秒おきに更新) (オプション)  
47. [ ] **Step 47**: レスポンシブレイアウトをテスト (スマホ表示で崩れないか)  
48. [ ] **Step 48**: 主要コンポーネント (カード, テーブル, グラフ) を部品化し再利用可能にする  
49. [ ] **Step 49**: 軽微なUX改善 (スケルトンスクリーン, ローディングインジケータ等) を導入  
50. [ ] **Step 50**: **Gitコミット**: "feat: create dashboard with mock data and UI components"

### 2.6. プロジェクト一覧・詳細 (Step 51〜60)

51. [ ] **Step 51**: `/projects` ページを新規作成し、プロジェクト一覧 (カード/テーブル等) を表示  
52. [ ] **Step 52**: 検索バーを実装 (名称の部分一致検索など)  
53. [ ] **Step 53**: フィルタリング (active, archived など) のドロップダウン設置  
54. [ ] **Step 54**: ページネーション・無限スクロールを導入 (データ量が多い場合に備える)  
55. [ ] **Step 55**: プロジェクトをクリックしたら `/projects/[id]` 詳細ページへ遷移  
56. [ ] **Step 56**: `/projects/[id]` でプロジェクト名、概要、状態(status)を表示  
57. [ ] **Step 57**: プロジェクト編集機能 (名前、説明、ステータス変更) をダイアログやフォームで実装  
58. [ ] **Step 58**: バックエンドAPI (仮 or 本実装) と連携して保存処理を行う  
59. [ ] **Step 59**: バリデーション (名称の必須チェックなど) を適用  
60. [ ] **Step 60**: **Gitコミット**: "feat: add project list & detail pages"

### 2.7. コミット一覧・詳細 (Step 61〜70)

61. [ ] **Step 61**: `/commits` ページを作成し、コミット履歴をテーブル表示  
62. [ ] **Step 62**: コミットメッセージや日時、作者 (ユーザ名) を表示する列を作る  
63. [ ] **Step 63**: コミットハッシュ (SHA) を短縮表示するなどの UI 調整  
64. [ ] **Step 64**: 検索機能 (コミットメッセージのキーワード検索)  
65. [ ] **Step 65**: コミット一覧から選択したコミットの `/commits/[id]` へ遷移  
66. [ ] **Step 66**: `CommitDetail` ページでメッセージ全文、差分リンク、変更ファイル一覧 (ダミー) を表示  
67. [ ] **Step 67**: 必要に応じてコミットステータス (draft, published等) の表示を追加  
68. [ ] **Step 68**: ページネーションや日付フィルタ (日付範囲指定) を実装  
69. [ ] **Step 69**: バックエンド連携 (Fetch commits API) → テーブルに反映  
70. [ ] **Step 70**: **Gitコミット**: "feat: implement commits list & detail pages"

### 2.8. ユーザー設定 (Step 71〜80)

71. [ ] **Step 71**: `/settings` ページを作成 (ユーザー情報編集やアカウント設定用)  
72. [ ] **Step 72**: ユーザー名、メールアドレス、プロフィール画像などを表示  
73. [ ] **Step 73**: 画像アップロードやアバター変更に対応 (モックでも OK)  
74. [ ] **Step 74**: 認証周り (パスワード変更、2FA等) のUI (オプション)  
75. [ ] **Step 75**: セキュリティ関連の注意喚起 (パスワード強度メーターなど)  
76. [ ] **Step 76**: リアルタイムバリデーション (メールアドレス形式など)  
77. [ ] **Step 77**: 保存ボタン押下時、バックエンドと連携 → ユーザー情報を更新  
78. [ ] **Step 78**: 成功/失敗時のトースト通知やエラー表示  
79. [ ] **Step 79**: ユーザープロフィールの見た目調整 (レイアウト)  
80. [ ] **Step 80**: **Gitコミット**: "feat: user settings page with profile update"

### 2.9. テスト実装・品質向上 (Step 81〜90)

81. [ ] **Step 81**: Jest と React Testing Library などの単体テスト環境を導入  
82. [ ] **Step 82**: 主要コンポーネント (Header, Footer, ProjectList など) のスナップショットテスト  
83. [ ] **Step 83**: フォームのバリデーションテスト (例えば空欄時のエラー表示)  
84. [ ] **Step 84**: カスタムフック (useAuth など) のテスト  
85. [ ] **Step 85**: テストカバレッジを確認し、薄い部分を補うテストを追加  
86. [ ] **Step 86**: Cypress など E2E テストツール導入 (ローカルで立ち上げたフロントに対して操作テスト)  
87. [ ] **Step 87**: ログイン → ダッシュボード → プロジェクト作成 → ログアウト などの**シナリオテスト**  
88. [ ] **Step 88**: ビルド時の型エラーやリンターエラーをゼロにするよう修正  
89. [ ] **Step 89**: 余計なコンソールログ・未使用変数を削除してコードをクリーンに  
90. [ ] **Step 90**: **Gitコミット**: "test: add unit & e2e tests for main components"

### 2.10. ビルド・デプロイ (Step 91〜100)

91. [ ] **Step 91**: `npm run build` (または `yarn build`) で本番ビルドを確認  
92. [ ] **Step 92**: バンドルサイズを確認 (必要に応じてコードスプリット等最適化)  
93. [ ] **Step 93**: CI ツール (GitHub Actions, CircleCI 等) で自動ビルド・テストを設定  
94. [ ] **Step 94**: デプロイ先 (Vercel, Netlify, AWS Amplify, etc.) を選定  
95. [ ] **Step 95**: 実際に初回デプロイを行い、URL で動作確認  
96. [ ] **Step 96**: 環境変数 (APIエンドポイント等) を設定し、本番環境でも正しく動くか検証  
97. [ ] **Step 97**: ダークモード対応やアクセシビリティ対応など追加タスクがあれば消化  
98. [ ] **Step 98**: バグ修正や軽微なUX改善 (エラーメッセージ, ローディングなど)  
99. [ ] **Step 99**: 機能仕様書や README, wiki ドキュメントを更新  
100. [ ] **Step 100**: **Gitコミット**: "chore: production build & deployment setup"

> **以上がフロントエンドの 100 ステップ**です。  
> 必要に応じて修正しながら進め、完了項目にチェックを入れてください。

---

## 3. バックエンド開発フロー (Step 101〜200)

続いて、バックエンド側の **100 ステップ**です。

### 3.1. プロジェクト初期化 (Step 101〜110)

101. [ ] **Step 101**: `backend/` ディレクトリへ移動  
102. [ ] **Step 102**: `npm init -y` などでプロジェクトを初期化  
103. [ ] **Step 103**: 使用フレームワークをインストール (Express / Nest.js / Fastifyなど)  
104. [ ] **Step 104**: TypeScript を導入し、`tsconfig.json` を設定  
105. [ ] **Step 105**: `.eslintrc`, `.prettierrc` などのツールを整備  
106. [ ] **Step 106**: `package.json` の `scripts` に `dev`, `build`, `start`, `test` などを設定  
107. [ ] **Step 107**: **Gitコミット**: "Backend init: setup project & configs"  
108. [ ] **Step 108**: 環境変数管理 (dotenvなど) を導入する  
109. [ ] **Step 109**: サーバーのポートやベースURL など基本設定を `config/` などにまとめる  
110. [ ] **Step 110**: README やドキュメントにバックエンドの起動手順を記載

### 3.2. データベース設定 (Step 111〜120)

111. [ ] **Step 111**: DB 選定 (PostgreSQL / MySQL / MongoDB 等) → インストール or SaaS (Supabase / Firebase)  
112. [ ] **Step 112**: DB接続ライブラリ (pg, mysql2, etc) または ORM (Prisma, TypeORM, Sequelize) を導入  
113. [ ] **Step 113**: `.env` に DB接続文字列を記載 (例: `DATABASE_URL=postgresql://...`)  
114. [ ] **Step 114**: 接続テストスクリプトを作成し、実際に DB へ接続できるか確認  
115. [ ] **Step 115**: データベースの**マイグレーション**ツール (Prisma migration, TypeORM CLI など) を設定  
116. [ ] **Step 116**: **User** テーブル(もしくはコレクション)のスキーマを定義  
117. [ ] **Step 117**: **Project** テーブルのスキーマを定義 (id, name, user_id, status など)  
118. [ ] **Step 118**: **Commit** テーブルのスキーマを定義 (id, project_id, message, timestamp など)  
119. [ ] **Step 119**: マイグレーションを実行し、DB にテーブルを作成  
120. [ ] **Step 120**: **Gitコミット**: "chore: configure DB and initial migrations"

### 3.3. ルーティング設計 (Step 121〜130)

121. [ ] **Step 121**: `src/routes/` ディレクトリを作成 (Expressの場合)  
122. [ ] **Step 122**: `/api/v1/users`, `/api/v1/projects`, `/api/v1/commits` 等のルートファイルを配置  
123. [ ] **Step 123**: ルーティングの基本形 (GET, POST, PUT, DELETE) を作成 (モックレスポンス可)  
124. [ ] **Step 124**: リクエストに対する**バリデーション** (Joi, class-validator等) の基盤を整備  
125. [ ] **Step 125**: 例: `/api/v1/users` → GET でユーザー一覧を返すダミー実装  
126. [ ] **Step 126**: 例: `/api/v1/projects` → GET でプロジェクト一覧を返すダミー実装  
127. [ ] **Step 127**: 例: `/api/v1/commits` → GET でコミット一覧を返すダミー実装  
128. [ ] **Step 128**: エラー時のレスポンス統一 (JSON 形式のエラーメッセージなど)  
129. [ ] **Step 129**: ログ出力 (Morgan等) や CORS 対応 (必要に応じて) を導入  
130. [ ] **Step 130**: **Gitコミット**: "feat: add basic routing with mock responses"

### 3.4. コントローラ・サービス層 (Step 131〜140)

131. [ ] **Step 131**: `src/controllers/` に各エンドポイントの処理をまとめる (`userController.ts`, etc.)  
132. [ ] **Step 132**: `src/services/` にビジネスロジックを切り出し (DB操作, 計算ロジック等)  
133. [ ] **Step 133**: `getUserList`, `createUser`, `updateUser` など、各機能をメソッド化  
134. [ ] **Step 134**: `projectService.ts` で CRUD 関数を定義 (例: `getProjectsByUserId`)  
135. [ ] **Step 135**: `commitService.ts` で CRUD 関数を定義 (例: `getCommitsByProjectId`)  
136. [ ] **Step 136**: コントローラはサービス層を呼び出して、HTTP レスポンスを返す構造に分離  
137. [ ] **Step 137**: 例: `POST /api/v1/projects` → `projectService.createProject()` → DB 保存  
138. [ ] **Step 138**: 例: `GET /api/v1/commits/:id` → `commitService.findCommitById(id)` → レスポンス  
139. [ ] **Step 139**: ユニットテストが書きやすいように依存注入 (DI) を検討 (Nest.js の場合は標準機能)  
140. [ ] **Step 140**: **Gitコミット**: "feat: implement service & controller logic"

### 3.5. 認証・認可 (Step 141〜150)

141. [ ] **Step 141**: 認証方式を選定 (JWT, Session + Cookie, OAuth など)  
142. [ ] **Step 142**: `authController.ts` を作成し、 `/api/v1/auth/login` などエンドポイントを用意  
143. [ ] **Step 143**: パスワードのハッシュ化 (bcrypt など) を導入 (ユーザー登録・ログイン)  
144. [ ] **Step 144**: ログイン成功時に JWT を発行 → フロントエンドに返却  
145. [ ] **Step 145**: ミドルウェア (`authMiddleware.ts`) を作成し、JWT 検証を実装  
146. [ ] **Step 146**: 認可 (ロールや所有権チェックなど) が必要な場合はガードを追加  
147. [ ] **Step 147**: `/api/v1/projects` や `/api/v1/commits` を保護 → ログイン時のみアクセス可  
148. [ ] **Step 148**: トークンの有効期限やリフレッシュトークンの管理方針を決定  
149. [ ] **Step 149**: `logout` 処理 (トークン無効化 or クライアント側削除) を定義 (必要に応じ)  
150. [ ] **Step 150**: **Gitコミット**: "feat: add JWT auth & authorization middleware"

### 3.6. DB操作 (Step 151〜160)

151. [ ] **Step 151**: ORM (Prisma, TypeORM等) で**リレーション**を設定 (User-Project, Project-Commit 等)  
152. [ ] **Step 152**: `User` と `Project` の 1対多関係をマッピング  
153. [ ] **Step 153**: `Project` と `Commit` の 1対多関係をマッピング  
154. [ ] **Step 154**: DBクエリの複雑度を確認 (集計や結合が必要な場合)  
155. [ ] **Step 155**: 例: プロジェクトごとのコミット数を返すエンドポイントなど (集計クエリ)  
156. [ ] **Step 156**: 大量データへの対策 (オプション: インデックス付与、パーティショニング等)  
157. [ ] **Step 157**: **トランザクション**の導入 (複数テーブル更新時に不整合が起きないように)  
158. [ ] **Step 158**: 外部キー制約 (ON DELETE CASCADE など) を設定し、整合性を確保  
159. [ ] **Step 159**: `commitService` に検索 (by date range, by author) 等の機能を拡張  
160. [ ] **Step 160**: **Gitコミット**: "chore: refine DB relations & advanced queries"

### 3.7. テスト (Step 161〜170)

161. [ ] **Step 161**: テストフレームワーク (Jest, Mocha + Chai 等) を導入  
162. [ ] **Step 162**: ユニットテスト (service層) でビジネスロジックを検証  
163. [ ] **Step 163**: コントローラの結合テスト (Supertest 等で HTTPリクエスト → レスポンスを確認)  
164. [ ] **Step 164**: ダミーDB もしくはテスト用DB でテスト実行 (In-memory DB かローカルテストDB)  
165. [ ] **Step 165**: 認証ルート (`/login`, `/logout`) のテスト (正しいJWT が返るか)  
166. [ ] **Step 166**: バリデーションテスト (必須項目が抜けている場合の 400 エラー確認など)  
167. [ ] **Step 167**: ログ/例外ハンドラーのテスト (意図的にエラーを起こし、レスポンスを確認)  
168. [ ] **Step 168**: テストカバレッジを取得し、不足分を追加  
169. [ ] **Step 169**: E2E テスト (フロントと連携して確認) を視野に、テストデータの事前投入も検討  
170. [ ] **Step 170**: **Gitコミット**: "test: add unit & integration tests for backend"

### 3.8. ロギング・セキュリティ強化 (Step 171〜180)

171. [ ] **Step 171**: ログライブラリ (Winston, pino など) を導入  
172. [ ] **Step 172**: リクエストログ (ルート, メソッド, ステータスコード, 処理時間) を詳細に取得  
173. [ ] **Step 173**: エラーログをスタックトレース含めて出力 or 監視ツールに送信 (Sentry等)  
174. [ ] **Step 174**: HTTPヘッダーのセキュリティ (Helmet等で XSS, CSRF 対策)  
175. [ ] **Step 175**: CSRFトークンの導入 (Cookieベース認証なら)  
176. [ ] **Step 176**: レートリミット (特定IPからの過剰アクセスに制限)  
177. [ ] **Step 177**: データベース内の秘密情報 (APIキー等) を暗号化 or セキュアストレージ保管  
178. [ ] **Step 178**: パフォーマンス測定 (APMツール, pino-http など)  
179. [ ] **Step 179**: 負荷テスト (Artillery, k6等) でベンチマークを取得  
180. [ ] **Step 180**: **Gitコミット**: "feat: enhance logging, security, and performance"

### 3.9. ビルド・デプロイ (Step 181〜190)

181. [ ] **Step 181**: `npm run build` (TypeScript → JavaScript トランスパイル)  
182. [ ] **Step 182**: ビルド生成物 (distフォルダなど) が正しく作成されるか確認  
183. [ ] **Step 183**: Docker 化を検討する (Dockerfile 作成 → `docker build` → コンテナ実行)  
184. [ ] **Step 184**: Docker Compose で DB と連携し、ローカル一発起動できる仕組みを整備  
185. [ ] **Step 185**: CI/CD (GitHub Actions 等) でビルド・テストを自動化  
186. [ ] **Step 186**: デプロイ先 (AWS ECS, EC2, Heroku, Render.comなど) を選定  
187. [ ] **Step 187**: 環境変数 (DB接続情報, JWT_SECRETなど) を本番用に設定  
188. [ ] **Step 188**: 本番デプロイを実行し、エラーがないかログを確認  
189. [ ] **Step 189**: ポストデプロイのヘルスチェック (API応答確認)  
190. [ ] **Step 190**: **Gitコミット**: "chore: finalize build & deployment pipeline"

### 3.10. 運用・メンテナンス (Step 191〜200)

191. [ ] **Step 191**: 運用フェーズの監視ツール設定 (CloudWatch, New Relic, Datadogなど)  
192. [ ] **Step 192**: アプリケーションログとサーバリソース (CPU, メモリ) を常時監視  
193. [ ] **Step 193**: アラート設定 (閾値超え時にSlackやメール通知)  
194. [ ] **Step 194**: 定期的なDBバックアップやスナップショットの取得  
195. [ ] **Step 195**: 長期的に参照するログや解析用データの保管場所を決定 (S3等)  
196. [ ] **Step 196**: リファクタリングタスク (コードの可読性やパフォーマンス向上) を計画  
197. [ ] **Step 197**: サーババージョンアップ (Node.js の LTS更新, セキュリティパッチ適用など)  
198. [ ] **Step 198**: 新機能追加時の DB スキーマ変更手順 (マイグレーション) を確立  
199. [ ] **Step 199**: 開発チーム内での定期的な振り返り (レトロスペクティブ) を実施  
200. [ ] **Step 200**: **Gitコミット**: "chore: operational setup & final maintenance tasks"

> **以上がバックエンドの 100 ステップ**です。  
> すべて完了した段階で、フロントエンドとバックエンドを接続し、総合テストに移行してください。

---

## 4. 最終的な確認

- **合計 200 ステップ**（フロントエンド 1〜100、バックエンド 101〜200）で構成しています。  
- 必要に応じて **順番を入れ替える**、**同時並行** で進める、または **スキップ** する項目があっても構いません。  
- 各ステップで**Gitコミット**や**ドキュメント更新**を行い、進捗をチーム内で共有してください。

---

## 5. 並行開発に関する補足

- フロントエンド/バックエンドで **API仕様書** を先に定義し、モックを用いれば**同時進行**が可能です。  
- フロントエンド担当は `/api/v1/...` への仮リクエストを行い、テスト用 JSON を返す仕組みを準備。  
- バックエンド担当は、本実装が整った段階でフロントエンドのエンドポイントを**モックから切り替え**。  
- 連携検証を早期に行うことで、**仕様の齟齬**や**インターフェースの不整合**を未然に防ぎます。

---

## 6. まとめ

- 本手順書は、**細かいタスクを 200 個以上**に分解し、抜け漏れを減らすためのものです。  
- 実際のプロジェクトでは優先度やスケジュールに応じて、作業を前後させたり同時並行で進めたり調整してください。  
- すべてのステップ完了後、必要に応じて **運用ドキュメント** や **追加機能** のタスクを検討してください。

以上のフローを参考に、プロジェクト開発を進めてください。  
**Good luck & Happy coding!**
